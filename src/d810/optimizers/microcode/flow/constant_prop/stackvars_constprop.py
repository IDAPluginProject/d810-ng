from __future__ import annotations

"""Global forward constant-propagation of stack / frame variables.

This pass is a *function-level* optimisation implemented as a
``FlowOptimizationRule`` (triggered by BlockOptimizerManager).  It
performs a classical forward data-flow analysis to discover constant
values stored in stack slots or in the registers that serve as stack
variables, and then rewrites instructions to embed those constants.

The code is largely based on the earlier peephole version found in
``optimizers/microcode/instructions/peephole/propagate_stackvars.py``
but fixed to handle CFG merge points correctly.

Only the left operand (``ins.l``) and explicit memory reads are folded.
This keeps the implementation reasonably safe while still catching the
vast majority of constant-load patterns generated by modern compilers.
"""

import logging
from collections import defaultdict

import ida_hexrays

from d810 import _compat
from d810.conf.loggers import getLogger
from d810.hexrays.hexrays_formatters import format_mop_t, opcode_to_string, sanitize_ea
from d810.optimizers.microcode.flow.handler import FlowOptimizationRule

logger = getLogger(__name__, default_level=logging.DEBUG)


class StackVariableConstantPropagationRule(FlowOptimizationRule):
    """Forward constant propagation for stack variables (function-wide)."""

    DESCRIPTION = "Fold stack variables that are assigned constant values across the whole function"

    # Opcodes through which we *may* propagate constants.  Anything with
    # side-effects on control-flow is deliberately excluded.
    ALLOW_PROPAGATION_OPCODES: set[int] = {
        ida_hexrays.m_stx,
        ida_hexrays.m_mov,
        ida_hexrays.m_neg,
        ida_hexrays.m_lnot,
        ida_hexrays.m_bnot,
        ida_hexrays.m_xds,
        ida_hexrays.m_xdu,
        ida_hexrays.m_low,
        ida_hexrays.m_high,
        ida_hexrays.m_add,
        ida_hexrays.m_sub,
        ida_hexrays.m_mul,
        ida_hexrays.m_udiv,
        ida_hexrays.m_sdiv,
        ida_hexrays.m_umod,
        ida_hexrays.m_smod,
        ida_hexrays.m_or,
        ida_hexrays.m_and,
        ida_hexrays.m_xor,
        ida_hexrays.m_shl,
        ida_hexrays.m_shr,
        ida_hexrays.m_sar,
        ida_hexrays.m_cfadd,
        ida_hexrays.m_ofadd,
        ida_hexrays.m_cfshl,
        ida_hexrays.m_cfshr,
        ida_hexrays.m_sets,
        ida_hexrays.m_seto,
        ida_hexrays.m_setp,
        ida_hexrays.m_setnz,
        ida_hexrays.m_setz,
        ida_hexrays.m_setae,
        ida_hexrays.m_setb,
        ida_hexrays.m_seta,
        ida_hexrays.m_setbe,
        ida_hexrays.m_setg,
        ida_hexrays.m_setge,
        ida_hexrays.m_setl,
        ida_hexrays.m_setle,
    }

    # run only once per function / maturity pair
    def __init__(self):
        super().__init__()
        self._done_funcs: set[tuple[int, int]] = set()
        # run after SSA renaming is stable
        self.maturities = [ida_hexrays.MMAT_CALLS]

    # ------------------------------------------------------------------
    #  FlowOptimizationRule interface
    # ------------------------------------------------------------------

    @_compat.override
    def optimize(self, blk: ida_hexrays.mblock_t):
        mba = blk.mba
        if mba is None:
            return 0
        key = (mba.entry_ea, mba.maturity)
        if key in self._done_funcs:
            return 0  # already processed in this maturity

        changed = self._run_on_function(mba)
        self._done_funcs.add(key)
        return changed

    # ------------------------------------------------------------------
    #  High-level driver
    # ------------------------------------------------------------------

    def _run_on_function(self, mba: ida_hexrays.mba_t) -> int:
        # Phase A – analysis
        in_map, out_map = self._run_dataflow(mba)

        # Phase B – rewrite
        nb_changes = 0
        for blk in mba.blocks:
            consts = in_map[blk.serial].copy()
            ins = blk.head
            while ins:
                nb_changes += self._rewrite_instruction(ins, consts)
                # Update map with effects of *original* instruction (not rewritten):
                self._transfer_single(ins, consts)
                ins = ins.next
        if nb_changes:
            mba.mark_chains_dirty()
            mba.optimize_local(0)
            mba.verify(True)
        return nb_changes

    # ------------------------------------------------------------------
    #  Phase A – forward data-flow analysis
    # ------------------------------------------------------------------

    def _run_dataflow(self, mba: ida_hexrays.mba_t):
        nb_blocks = mba.qty
        IN: dict[int, dict[str, tuple[int, int]]] = {
            idx: {} for idx in range(nb_blocks)
        }
        OUT: dict[int, dict[str, tuple[int, int]]] = {
            idx: {} for idx in range(nb_blocks)
        }

        # worklist initialised with all blocks
        worklist: list[int] = list(range(nb_blocks))

        preds_cache = {blk.serial: list(blk.predset) for blk in mba.blocks}
        while worklist:
            b_idx = worklist.pop()
            preds = preds_cache[b_idx]
            if preds:
                in_map = self._meet([OUT[p] for p in preds])
            else:
                in_map = {}
            if in_map != IN[b_idx]:
                IN[b_idx] = in_map
            out_map_new = self._transfer_block(mba.get_mblock(b_idx), in_map)
            if out_map_new != OUT[b_idx]:
                OUT[b_idx] = out_map_new
                # enqueue successors
                blk = mba.get_mblock(b_idx)
                for succ in blk.succset:
                    if succ not in worklist:
                        worklist.append(succ)
        return IN, OUT

    # meet: intersection of keys, keep only if values agree
    @staticmethod
    def _meet(pred_outs: list[dict[str, tuple[int, int]]]):
        if not pred_outs:
            return {}
        keys = set.intersection(*(set(m.keys()) for m in pred_outs))
        res: dict[str, tuple[int, int]] = {}
        for k in keys:
            vals = {m[k] for m in pred_outs}
            if len(vals) == 1:
                res[k] = vals.pop()
        return res

    def _transfer_block(
        self, blk: ida_hexrays.mblock_t, in_map: dict[str, tuple[int, int]]
    ):
        out_map = dict(in_map)
        ins = blk.head
        while ins:
            self._transfer_single(ins, out_map)
            ins = ins.next
        return out_map

    # update the map in place for a single instruction
    def _transfer_single(
        self, ins: ida_hexrays.minsn_t, env: dict[str, tuple[int, int]]
    ):
        # Conservatively handle function calls, which can have arbitrary side
        # effects on stack memory. Kill all tracked stack variables.
        if ins.opcode in (ida_hexrays.m_call, ida_hexrays.m_icall):
            vars_to_kill = [k for k in env if k.startswith(("%var_", "stk_"))]
            if vars_to_kill:
                if logger.debug_on:
                    logger.debug(
                        "[stack-var-cprop] KILL: all stack vars at ea=%X due to call",
                        sanitize_ea(ins.ea),
                    )
                for k in vars_to_kill:
                    del env[k]

        # Determine the variable being written to (the KILL set).
        written_var = self._get_written_var_name(ins)
        is_const_assign = self._is_constant_stack_assignment(ins)

        # KILL the variable from the environment if it's being overwritten by a
        # non-constant value.
        if written_var and not is_const_assign and written_var in env:
            if logger.debug_on:
                logger.debug(
                    "[stack-var-cprop] KILL: %s at ea=%X due to non-const write (%s)",
                    written_var,
                    sanitize_ea(ins.ea),
                    opcode_to_string(ins.opcode),
                )
            del env[written_var]

        # Add the variable to the environment if it's a new constant assignment
        # (the GEN set).
        if is_const_assign:
            result = self._extract_assignment(ins)
            if result:
                var, val_size = result
                if var:
                    if logger.debug_on:
                        logger.debug(
                            "[stack-var-cprop] GEN: %s = 0x%X at ea=%X",
                            var,
                            val_size[0],
                            sanitize_ea(ins.ea),
                        )
                    env[var] = val_size

    # ------------------------------------------------------------------
    #  Phase B – rewriting helpers
    # ------------------------------------------------------------------

    def _rewrite_instruction(
        self, ins: ida_hexrays.minsn_t, env: dict[str, tuple[int, int]]
    ) -> int:
        if ins.opcode not in self.ALLOW_PROPAGATION_OPCODES:
            return 0
        changed = 0
        # Only process left operand
        op = getattr(ins, "l", None)
        if op is not None and self._process_operand(op, env):
            changed += 1
            if logger.debug_on:
                logger.debug("[stack-var-cprop] folded at ea=%X", sanitize_ea(ins.ea))
        return changed

    # ------------------------------------------------------------------
    #  Low-level helpers (mostly ported from the old peephole version)
    # ------------------------------------------------------------------

    def _get_written_var_name(self, ins: ida_hexrays.minsn_t) -> str | None:
        """Get the unique name of a variable written to by an instruction."""
        if ins.d is None:
            return None

        # Direct write to a stack variable or register. This covers mov, add, etc.
        if ins.d.t in (ida_hexrays.mop_S, ida_hexrays.mop_r):
            return self._get_stack_var_name(ins.d)

        # A store instruction (stx) writes to a memory location.
        if ins.opcode == ida_hexrays.m_stx:
            # The destination operand `d` is the address.
            if ins.d.t == ida_hexrays.mop_S:
                return self._get_stack_var_name(ins.d)

            # Address is an expression, e.g., [base+offset]
            if (
                ins.d.t == ida_hexrays.mop_d
                and ins.d.d is not None
                and ins.d.d.opcode == ida_hexrays.m_add
            ):
                base, offset = None, 0
                if ins.d.d.l and ins.d.d.l.t in (
                    ida_hexrays.mop_S,
                    ida_hexrays.mop_r,
                ):
                    base = ins.d.d.l
                    if ins.d.d.r and ins.d.d.r.t == ida_hexrays.mop_n:
                        offset = ins.d.d.r.nnn.value
                elif ins.d.d.r and ins.d.d.r.t in (
                    ida_hexrays.mop_S,
                    ida_hexrays.mop_r,
                ):
                    base = ins.d.d.r
                    if ins.d.d.l and ins.d.d.l.t == ida_hexrays.mop_n:
                        offset = ins.d.d.l.nnn.value

                if base is not None:
                    var_name = self._get_stack_var_name(base)
                    if var_name:
                        return f"{var_name}+{offset:X}" if offset else var_name
        return None


    def _is_constant_stack_assignment(self, ins: ida_hexrays.minsn_t) -> bool:
        """Return True if *ins* writes a literal number to a stack location."""
        if ins.opcode == ida_hexrays.m_mov:
            return (
                ins.l is not None
                and ins.l.t == ida_hexrays.mop_n
                and ins.d is not None
                and ins.d.t == ida_hexrays.mop_S
            )
        if ins.opcode == ida_hexrays.m_stx:
            if ins.l is None or ins.l.t != ida_hexrays.mop_n:
                return False
            if ins.d is not None and ins.d.t == ida_hexrays.mop_S:
                return True
            # (base+offset) form handled loosely – assume constant if base is stack var
            if (
                ins.d is not None
                and ins.d.t == ida_hexrays.mop_d
                and ins.d.d is not None
                and ins.d.d.opcode == ida_hexrays.m_add
            ):
                lt = ins.d.d.l.t if ins.d.d.l else None
                rt = ins.d.d.r.t if ins.d.d.r else None
                if (
                    lt in (ida_hexrays.mop_S, ida_hexrays.mop_r)
                    and rt == ida_hexrays.mop_n
                ) or (
                    rt in (ida_hexrays.mop_S, ida_hexrays.mop_r)
                    and lt == ida_hexrays.mop_n
                ):
                    return True
        return False

    def _extract_assignment(self, ins: ida_hexrays.minsn_t):
        """Return (var_name, (value, size)) for a constant assignment or None."""
        if ins.l is None or ins.l.t != ida_hexrays.mop_n:
            return
        value = ins.l.nnn.value
        size = ins.l.size
        if (
            ins.opcode == ida_hexrays.m_mov
            and ins.d is not None
            and ins.d.t == ida_hexrays.mop_S
        ):
            var = self._get_stack_var_name(ins.d)
            return var, (value, size)
        if ins.opcode == ida_hexrays.m_stx and ins.d is not None:
            if ins.d.t == ida_hexrays.mop_S:
                var = self._get_stack_var_name(ins.d)
                return var, (value, size)
            # (base+offset)
            if (
                ins.d.t == ida_hexrays.mop_d
                and ins.d.d is not None
                and ins.d.d.opcode == ida_hexrays.m_add
            ):
                base, offset = None, 0
                if ins.d.d.l and ins.d.d.l.t in (ida_hexrays.mop_S, ida_hexrays.mop_r):
                    base = ins.d.d.l
                    if ins.d.d.r and ins.d.d.r.t == ida_hexrays.mop_n:
                        offset = ins.d.d.r.nnn.value
                elif ins.d.d.r and ins.d.d.r.t in (
                    ida_hexrays.mop_S,
                    ida_hexrays.mop_r,
                ):
                    base = ins.d.d.r
                    if ins.d.d.l and ins.d.d.l.t == ida_hexrays.mop_n:
                        offset = ins.d.d.l.nnn.value
                if base is not None:
                    var = self._get_stack_var_name(base)
                    if var is not None:
                        comp = f"{var}+{offset:X}" if offset else var
                        return comp, (value, size)
        return

    # ------------------------------------------------------------------
    #  Operand folding helpers (re-used from old rule)
    # ------------------------------------------------------------------

    def _process_operand(
        self, op: ida_hexrays.mop_t, consts: dict[str, tuple[int, int]]
    ):
        changed = False
        if op.t == ida_hexrays.mop_S:
            var_name = self._get_stack_var_name(op)
            if var_name and var_name in consts:
                value, _size = consts[var_name]
                truncated = value & ((1 << (op.size * 8)) - 1)
                op.make_number(truncated, op.size)
                changed = True
        elif op.t == ida_hexrays.mop_r:
            reg_name = self._get_stack_var_name(op)
            if reg_name and reg_name in consts:
                value, _size = consts[reg_name]
                op.make_number(value, op.size)
                changed = True
        elif op.t == ida_hexrays.mop_d and op.d is not None:
            # recurse into memory expression
            if op.d.opcode in (ida_hexrays.m_ldx, ida_hexrays.m_ldc):
                addr = op.d.r if op.d.r else op.d.l
                if addr and addr.t == ida_hexrays.mop_S:
                    var_name = self._get_stack_var_name(addr)
                    if var_name and var_name in consts:
                        value, size = consts[var_name]
                        op.make_number(value, size)
                        changed = True
                elif (
                    addr
                    and addr.t == ida_hexrays.mop_d
                    and addr.d is not None
                    and addr.d.opcode == ida_hexrays.m_add
                ):
                    base, offset = None, 0
                    if addr.d.l and addr.d.l.t in (
                        ida_hexrays.mop_S,
                        ida_hexrays.mop_r,
                    ):
                        base = addr.d.l
                        if addr.d.r and addr.d.r.t == ida_hexrays.mop_n:
                            offset = addr.d.r.nnn.value
                    elif addr.d.r and addr.d.r.t in (
                        ida_hexrays.mop_S,
                        ida_hexrays.mop_r,
                    ):
                        base = addr.d.r
                        if addr.d.l and addr.d.l.t == ida_hexrays.mop_n:
                            offset = addr.d.l.nnn.value
                    if base is not None:
                        var_name = self._get_stack_var_name(base)
                        comp = f"{var_name}+{offset:X}" if offset else var_name
                        if comp in consts:
                            value, size = consts[comp]
                            op.make_number(value, size)
                            changed = True
            else:
                # generic recursion into .d sub-operands
                for attr in ("l", "r", "d"):
                    sub = getattr(op.d, attr, None)
                    if sub is not None and self._process_operand(sub, consts):
                        changed = True
        elif op.t == ida_hexrays.mop_f and op.f is not None:
            for a in op.f.args:
                if a and self._process_operand(a, consts):
                    changed = True
        return changed

    # name helpers -----------------------------------------------------

    def _get_stack_var_name(self, mop: ida_hexrays.mop_t) -> str | None:
        base_name = None
        if mop.t == ida_hexrays.mop_S:
            mba = getattr(mop.s, "mba", None)
            frame_size = None
            if mba is not None:
                for attr in ("minstkref", "stacksize", "frsize", "fullsize"):
                    val = getattr(mba, attr, None)
                    if val:
                        disp = val - mop.s.off
                        if disp >= 0:
                            frame_size = val
                            break
            if frame_size is not None:
                disp_off = frame_size - mop.s.off
                base_name = f"%var_{disp_off:X}.{mop.size}"
            else:
                base_name = f"stk_{mop.s.off:X}.{mop.size}"
            return f"{base_name}{{{mop.valnum}}}"
        elif mop.t == ida_hexrays.mop_r:
            base_name = ida_hexrays.get_mreg_name(mop.r, mop.size)
            return f"{base_name}.{mop.size}{{{mop.valnum}}}"
        return base_name
