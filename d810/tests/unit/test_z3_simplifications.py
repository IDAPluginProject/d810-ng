import re
import unittest

from z3 import And, BitVec, BitVecVal, If, LShR, Solver, is_bool, sat, simplify, unsat

# ---------------------------------------------------------------------------
# Use autogenerated rule metadata instead of the old hard-coded strings
# ---------------------------------------------------------------------------
from .z3_rule_metadata import KNOWN_INCORRECT_RULES, RULE_BY_EXPR, RULES


class TestBitwiseSimplifications(unittest.TestCase):
    """
    A comprehensive unit test to validate a list of bitwise and arithmetic
    simplifications using the Z3 SMT solver.

    This test identifies several types of rules:
    1.  VALID: Rules that are universally true.
    2.  VALID WITH CONSTRAINTS: Rules that are true only when certain relationships
        between their constants hold (defined in CONSTRAINT_MAP).
    3.  INCORRECT: Rules from the original list that are not universally true
        and are not easily fixable with simple constraints. These are moved to
        KNOWN_INCORRECT_RULES and skipped.
    """

    # --- Test Configuration ---
    BIT_WIDTH = 32  # Bit width for Z3 variables (e.g., 8, 16, 32, 64)

    # --- Constraint Definitions ---
    CONSTRAINT_MAP = {
        # This identity requires that the constants used in the `&` and `^` are disjoint.
        "(((x_0 ^ c_1_1) & c_2_1) | ((x_0 ^ c_1_2) & c_2_2)) => (x_0 ^ c_res)": lambda V: [
            V["c_res"] == ((V["c_1_1"] & V["c_2_1"]) | (V["c_1_2"] & V["c_2_2"])),
            (V["c_2_1"] & V["c_2_2"]) == 0,
        ],
        "((x_0 - c_0) + (c_1 * (x_0 - c_2))) => ((c_coeff * x_0) - c_sub)": lambda V: [
            V["c_coeff"] == 1 + V["c_1"],
            V["c_sub"] == V["c_0"] + (V["c_1"] * V["c_2"]),
        ],
        "(x_0 - (c_1 - x_1)) => (x_0 + (x_1 + c_res))": lambda V: [
            V["c_res"] == -V["c_1"]
        ],
        # This identity holds only if c_2 is the bitwise not of c_1
        "((x_0 & c_1) | (x_1 & c_2)) => (((x_0 ^ x_1) & c_1) ^ x_1)": lambda V: [
            V["c_2"] == ~V["c_1"]
        ],
        "((x_0 ^ c_1) & c_2) => ((x_0 & c_2) ^ c_res)": lambda V: [
            V["c_res"] == V["c_1"] & V["c_2"]
        ],
        "LShR((x_0 & c_1), c_2) => (LShR(x_0, c_2) & c_res)": lambda V: [
            V["c_res"] == LShR(V["c_1"], V["c_2"])
        ],
        "((x_0 & c_1) | c_2) => ((x_0 & c_res) | c_2)": lambda V: [
            V["c_res"] == V["c_1"] | V["c_2"]
        ],
        "((cst_1 & (x_0 ^ x_1)) ^ x_1) => ((x_0 & cst_1) ^ (x_1 & not_cst_1))": lambda V: [
            V["not_cst_1"] == ~V["cst_1"]
        ],
        "~((x_0 ^ c_1)) => (x_0 ^ bnot_c_1)": lambda V: [V["bnot_c_1"] == ~V["c_1"]],
        "~((x_0 | c_1)) => (~(x_0) & bnot_c_1)": lambda V: [V["bnot_c_1"] == ~V["c_1"]],
        "~((x_0 & c_1)) => (~(x_0) | bnot_c_1)": lambda V: [V["bnot_c_1"] == ~V["c_1"]],
        "((-(x_0) - 0x1) - (c_minus_2 * x_0)) => (x_0 - val_1)": lambda V: [
            V["c_minus_2"] == -2
        ],
        "((~(x_0) | 0x1) + x_0) => ((x_0 & val_1_1) - val_1_2)": lambda V: [
            V["val_1_1"] == 1,
            V["val_1_2"] == 1,
        ],
    }

    def _to_bv_if_bool(self, expr):
        """Converts a Z3 boolean expression to a 1-bit or 0-bit vector."""
        if is_bool(expr):
            return If(expr, BitVecVal(1, self.BIT_WIDTH), BitVecVal(0, self.BIT_WIDTH))
        return expr

    def _parse_and_prove(self, rule_str):
        """Parses a single rule string, and uses Z3 to prove its validity."""
        # 1. Pre-process and split the rule into LHS and RHS
        rule_str = rule_str.replace("==>", "=>")
        if "=>" not in rule_str:
            self.fail(f"Invalid rule format (missing '=>'): {rule_str}")

        if rule_str.endswith("=>  0xff"):
            rule_str = rule_str.replace("=>  0xff", "=> val_ff")

        lhs_str, rhs_str = [s.strip() for s in rule_str.split("=>")]

        # Skip rule with undefined function 'xdu'
        if "xdu" in rule_str:
            print(f"\nSKIPPING rule with undefined function 'xdu': {rule_str}")
            return

        # 2. Find all unique identifiers
        identifiers = set(re.findall(r"[a-zA-Z_][a-zA-Z0-9_]*", f"{lhs_str} {rhs_str}"))

        # 3. Create the evaluation context
        context = {"LShR": LShR, "__builtins__": {"int": int, "hex": hex}}
        bw = self.BIT_WIDTH

        named_constants = {
            "val_0": 0,
            "val_1": 1,
            "val_2": 2,
            "val_ff": (1 << bw) - 1,
            "val_fe": (1 << bw) - 2,
            "minus_1": (1 << bw) - 1,
        }
        for name, val in named_constants.items():
            if name in identifiers:
                context[name] = BitVecVal(val, bw)

        for name in identifiers:
            if name in context or name == "LShR":
                continue

            base_name, is_bnot = (
                (name.split("_", 1)[1], True)
                if name.startswith(("bnot_", "lnot_", "not_"))
                else (name, False)
            )

            if base_name not in context:
                context[base_name] = BitVec(base_name, bw)
            if is_bnot:
                context[name] = ~context[base_name]
            elif name not in context:
                context[name] = BitVec(name, bw)

        # 4. Create Z3 Solver and add constraints
        solver = Solver()
        if rule_str in self.CONSTRAINT_MAP:
            constraints = self.CONSTRAINT_MAP[rule_str](context)
            solver.add(constraints)

        # 5. Evaluate LHS and RHS strings into Z3 expressions
        try:
            lhs_expr = eval(lhs_str, {"LShR": LShR}, context)
            rhs_expr = eval(rhs_str, {"LShR": LShR}, context)
        except Exception as e:
            self.fail(
                f"Failed to parse/evaluate expression in rule: {rule_str}\nError: {e}"
            )

        # 6. IMPORTANT: Convert any boolean results to bitvectors to avoid sort mismatch
        lhs_bv = self._to_bv_if_bool(lhs_expr)
        rhs_bv = self._to_bv_if_bool(rhs_expr)

        # 7. Prove equivalence by asserting inequality
        solver.add(lhs_bv != rhs_bv)
        result = solver.check()

        if result == sat:
            model = solver.model()
            # Build a clear counterexample string
            decls = model.decls()
            sorted_decls = sorted(decls, key=lambda d: d.name())
            counter_str = ", ".join([f"{d.name()} = {model[d]}" for d in sorted_decls])

            # Safely evaluate expressions with the model
            try:
                lhs_val = model.eval(lhs_bv, model_completion=True)
                rhs_val = model.eval(rhs_bv, model_completion=True)
                msg = (
                    f"\n--- FAIL: Simplification is NOT universally true ---\n"
                    f"Rule:           {rule_str}\n"
                    f"Counterexample: [{counter_str}]\n"
                    f"  - LHS value:    {lhs_val} {(f'(dec: {lhs_val.as_long()})' if hasattr(lhs_val, 'as_long') else '')}\n"
                    f"  - RHS value:    {rhs_val} {(f'(dec: {rhs_val.as_long()})' if hasattr(rhs_val, 'as_long') else '')}"
                )
            except Exception as e:
                msg = (
                    f"\n--- FAIL: Simplification is NOT universally true (error during eval) ---\n"
                    f"Rule:           {rule_str}\n"
                    f"Counterexample: [{counter_str}]\n"
                    f"Eval Error:     {e}"
                )
            self.fail(msg)
        elif result != unsat:
            self.fail(f"Z3 returned an unknown result for rule: {rule_str}")

    def test_simplifications(self):
        """
        Iterates through all defined rules and proves their equivalence using Z3.
        """
        # ------------------------------------------------------------------
        # Build lists from the metadata
        # ------------------------------------------------------------------
        all_rules = [r.expr for r in RULES]
        testable_rules = [r for r in all_rules if r not in KNOWN_INCORRECT_RULES]
        skipped_count = len(all_rules) - len(testable_rules)

        print(
            f"\nTesting {len(testable_rules)} unique bitwise simplifications "
            f"with Z3 (BIT_WIDTH={self.BIT_WIDTH})..."
        )
        if skipped_count > 0:
            print(f"Skipping {skipped_count} known incorrect or unprovable rules.")

        for i, rule in enumerate(testable_rules):
            with self.subTest(rule=rule):
                meta = RULE_BY_EXPR[rule]
                label = (
                    f"{meta.name} ({'incorrect' if meta.known_incorrect else 'valid'})"
                )
                print(f"  [{i+1}/{len(testable_rules)}] {label.ljust(40)}", end="\r")
                self._parse_and_prove(rule)
        print(
            f"\n\nSuccessfully proved {len(testable_rules)} simplifications. {' '*80}"
        )


if __name__ == "__main__":
    unittest.main()
